import { Repository, DataSource } from 'typeorm';
import { RepoToken } from '../db-providers/repo.token.enum';
import { UpdateContactResponse } from './responses/update.contact.response';
import { ConfigModule } from '@nestjs/config';
import { OutboxService } from './../outbox/outbox.service';
import { CreateContactResponse } from './responses/create.contact.response';
import { ContactSaveService } from './contact.save.service';
import { Contact } from './entities/contact.entity';
import { Injectable, Inject } from '@nestjs/common';
import { ContactAggregate } from './aggregate-types/contact.aggregate';
import { ContactAggregateEntities } from './aggregate-types/contact.aggregate.type';
import { CreateContactEvent } from '../events/contact/commands';
import { CreateEntityResponse } from 'src/common/responses/command.response-Delete';
import { ServerError, ServerErrorReasons, ClientErrorReasons } from '../common/errors/';
import { ContactCreatedEvent } from '../events/contact/domainChanges';
import { CustomNatsClient } from 'src/custom.nats.client.service';
import { ContactOutbox } from '../outbox/entities/contact.outbox.entity';
import { DomainChangeEventFactory } from './services/domain.change.event.factory';
import { DomainChangeEventManager } from 'src/outbox/domainchange.event.manager';
import { ConfigService }  from '@nestjs/config';
import { genBeforeAndAfterImage } from '../utils/gen.beforeAfter.image';
import { DataChanges } from '../common/responses/base.response';
import { UpdateContactEvent } from '../events/contact/commands';
import { logStart, logStop } from 'src/utils/trace.log';
import { BaseError, ClientError } from '../common/errors';
import { BaseResponse } from '../common/responses/base.response';
const logTrace = true;

@Injectable()
export class ContactService {
  
  private generatedEvents: Array<ContactCreatedEvent> = [];

  private domainChangeEventsEnabled: boolean = false;

  constructor(
    private contactAggregate: ContactAggregate,
    private customNatsClient: CustomNatsClient,
    private configService: ConfigService,
    private outboxService: OutboxService,
    private domainChangeEventFactory: DomainChangeEventFactory,
    private domainChangeEventManager: DomainChangeEventManager, 
    private contactSaveService: ContactSaveService,
    @Inject(RepoToken.DATA_SOURCE) private dataSource: DataSource
    // @Inject(RepoToken.CONTACT_REPOSITORY) private contactRepository: Repository<Contact>,
  ) {
    /* set domainChangeEventsEnabled flag */
    if (this.configService.get('PUBLISH_DOMAIN_CHANGE_EVENTS') === "true") {
      this.domainChangeEventsEnabled = true ;
    }
  }
  
  async updateAggregate(updateContactEvent: UpdateContactEvent): Promise<UpdateContactResponse | BaseError> {
    const methodName = 'updateAggregate';
    logTrace && logStart([methodName, 'payload'], arguments);
    
    const { header, message } = updateContactEvent;
    
    // Destructure message to extract keys (for fetching aggregate) and update properties (for applying changes) .
    const { id, accountId, ...updateProperties }  = message; 
    let updateRequest = { ...updateProperties }; /* ONLY INCLUDE updateProperties in updateRequest */

    /* fetch aggregate entities */
    const aggregateEntities: ContactAggregateEntities = await this.contactAggregate.getAggregateEntitiesBy(accountId, id);

    /* if not found return 404 */
    if (!aggregateEntities.contact) {
      let clientError = new ClientError(404);
      clientError.setReason(ClientErrorReasons.KeysNotInDatabase);
      clientError.setLongMessage(`id: ${id}`)
  
      return clientError;
    }

    /* generate before and after image  */
    const beforeAndAfterImage: DataChanges = this.contactAggregate.generateBeforeAndAfterImages(updateRequest, aggregateEntities);
    /* apply updates to aggregate entities */

    let updatedAggregateEntities: ContactAggregateEntities;
    updatedAggregateEntities = this.contactAggregate.applyUpdates(updateRequest, aggregateEntities)
       
    /* handle requirement for publishing domain updated event  */
    // this.prepareDomainUpdatedEvent(updateContactEvent, updatedAggregateEntities);
    
    // save changes
    let savedAggregateEntities: ContactAggregateEntities;
    savedAggregateEntities = await this.contactSaveService.save(updatedAggregateEntities);

    /* if save was NOT successful, return error response */
    if (!savedAggregateEntities.contact) {
      let serverError = new ServerError(500);
      serverError.setMessage(ServerErrorReasons.databaseError)
      serverError.setReason(`${methodName}: failed to update contact aggregate id:${id} `);
      return serverError;
    }
    
    // create response object
    const { id: contactId } = savedAggregateEntities.contact;
    const dataChanges: DataChanges =  beforeAndAfterImage;
    const updateContactResponse: UpdateContactResponse = new UpdateContactResponse(contactId);
    updateContactResponse.setUpdateImages(beforeAndAfterImage);
   
    logTrace && logStop(methodName, "updateContactResponse", updateContactResponse);
    return updateContactResponse;
  }

  // TO BE DETERMINED NEED TO DECIDE IF THIS IS NEEDED
  // IF I ENABLE THIS AGAIN, COPY EXCEPTOIN HANDLING FROM upgradeAggregate(payload)
  // async updateAggregateById(id: number, updateRequest): Promise<ContactUpdatedResponse | ServerError> {
  //   console.log("[A]")
  //   /* fetch aggregate entities */
  //   const aggregateEntities: ContactAggregateEntities = await this.getAggregateEntitiesById(id);
  //   console.log("[B]")
  //   /* apply updates to aggregate entities */
  //   let updatedAggregateEntities: ContactAggregateEntities;
  //   updatedAggregateEntities = this.contactAggregate.applyUpdates(updateRequest, aggregateEntities)
  //   console.log("updatedAggregateEntities")
  //   console.log(updatedAggregateEntities);
  //   console.log("[C]")
  //   /* generate before and after image  */
  //   const beforeAndAfterImage: DataChanges = this.contactAggregate.generateBeforeAndAfterImages(updateRequest, updatedAggregateEntities);
  //   console.log("beforeAndAfterImage");
  //   console.log(beforeAndAfterImage);
    
  //   console.log("[D]")

  //   /* handle requirement for publishing Created event  */
  //   // this.prepareDomainUpdatedEvent(updateContactEvent, aggregate);
    
  //   // save changes
  //   let savedAggregateEntities: ContactAggregateEntities;
  //   savedAggregateEntities = await this.contactSaveService.save(updatedAggregateEntities);
  //   console.log("[E]")

  //   /* if save was NOT successful, return error response */
  //   if (!savedAggregateEntities.contact) {
  //     return new ServerError(500);
  //   }
  //   console.log("[F]")
  //   // create response object
  //   const { id: contactId } = savedAggregateEntities.contact;
  //   const dataChanges: DataChanges =  beforeAndAfterImage;
  //   const contactUpdatedResponse: ContactUpdatedResponse = new ContactUpdatedResponse(contactId);
  //   contactUpdatedResponse.setUpdateImages(beforeAndAfterImage);
  //   console.log("contactUpdatedResponse")
  //   console.log(contactUpdatedResponse)

  //   console.log("[G]")
  //   return contactUpdatedResponse;
  // }
 
  // To Be DELETED
  // async getAggregateEntitiesById(id: number): Promise<ContactAggregateEntities> {
  //   return await this.contactAggregate.getAggregateEntitiesById(id);
  // }
 
  // service used to create aggreate, then save it.
  // async create(createContactEvent: CreateContactEvent):  Promise<CreateContactResponse | BaseError> {
  //   const methodName = 'create';
  //   logTrace && logStart([methodName, 'createContactEvent',createContactEvent ], arguments);

  //   const { sessionId, userId } = createContactEvent.header;
  //   const { accountId, email, firstName, lastName } = createContactEvent.message;

  //   /* reserve next outbox sequence id to use when creating aggregate instance */
  //   // const nextSeqId = await this.getNextOutboxSequence();

  //   /* create aggregate instance */
  //   let aggregate: ContactAggregate = await this.contactAggregate.createAggregate(createContactEvent);
  //   console.log("This is returned contact aggregate ", aggregate);
        
  //   /* Create aggregate (WITHOUT outbox entity) and return aggregate entities */
  //   let aggregate: ContactAggregate = await this.contactAggregate.idempotentCreate(aggregate);
   
  //   /* if save was NOT successful, return error response */
  //   if (!aggregate.contact) { return this.createAggregateError(email);  }
    
  //   /* pull out contactId and version, which is needed to generate Created Event  */
  //   const contactId = aggregate.contact.id;
  //   const version   = aggregate.contact.version;

  //   /* strip down aggregateEntities to aggregate root, to repeat save WITH outbox. */
  //   const aggregate: ContactAggregate = { 
  //     contact: aggregate.contact,
  //     contactAcctRel: null
  //   }

  //   /* this method will add the outbox entity to the minimized aggregateRoot */ 
  // //   this.prepareDomainCreatedEvent(createContactEvent, aggregate);

  // //   //  /* run save aggregate again (WITH outbox entity) and return aggregate entities */
  // //   //  let aggregateEntities: ContactAggregateEntities = await this.contactAggregate.idempotentCreate(aggregateRoot, nextSeqId);
  // //   //  /* if save was NOT successful, return error response */
  // //   //  if (!aggregateEntities.contact) { 
  // //   //   console.log(`WARNING: `)
  // //   // }
    
  // //   /* Sends command to outbox to publish unpublished events in outbox for a given account */
  //   const cmdResult: any = await this.domainChangeEventManager.triggerOutboxForAccount(accountId)

  // //   /* create response object using aggregateRoot.id */
  //   const { contact } = aggregateEntities;
  //   let createContactResponse: CreateContactResponse = new CreateContactResponse(contact.id);

  //   logTrace && logStop(methodName, 'createContactResponse', createContactResponse);
  //   return createContactResponse;
  // }

  /**
   * Prepares the event and the outbox instance to publish a domain created event.
   * Note that the domainChangeEventsEnabled flag must be set to publish events.
   * @param createContactEvent 
   * @param aggregate 
   */
  // async prepareDomainCreatedEvent(
  //   createContactEvent: CreateContactEvent, 
  //   aggregate: ContactAggregate)
  // {
  //   const methodName = 'prepareDomainCreatedEvent';
  //   logTrace && logStart([methodName, 'createContactEvent','aggregate'], arguments);
  //   /* If flag is disabled to publish domain change events, return */
  //   if (!this.domainChangeEventsEnabled) {  
  //     return;  
  //   } 
  //   /* extract version from aggregate to pass down to include in domainCreated event */
  //   const contact = aggregate.contact;
  //   const version: number = contact.version;

  //   /* create serialized contactCreatedEvent */
  //   const serializedContactCreatedEvent = this.domainChangeEventFactory.genCreatedEventFor(
  //     createContactEvent, aggregate
  //   );
  
  //   /* create Outbox Instance of contactCreatedEvent, from createContactEvent */
  //   let contactOutboxInstance: ContactOutbox = await this.outboxService.createContactCreatedInstance(
  //         createContactEvent, 
  //         serializedContactCreatedEvent
  //       );

  //   logTrace && logStop(methodName, 'contactOutboxInstance',contactOutboxInstance);
  //   /* append instance to the aggregate  */
  //   aggregate.contactOutbox = contactOutboxInstance;
  // }

  /**
   * Prepares the event and the outbox instance to publish a domain updated event.
   * Note that the domainChangeEventsEnabled flag must be set to publish events.
   * @param createContactEvent 
   * @param aggregate 
   */
  // async prepareDomainUpdatedEvent(
  //   updateContactEvent: UpdateContactEvent, 
  //   aggregate: ContactAggregateEntities) 
  // {
  //   const methodName = 'prepareDomainUpdatedEvent';
  //   logTrace && logStart([methodName, 'updateContactEvent','aggregate'], arguments);
  //   /* If flag is disabled to publish domain updated events, return */
  //   if (!this.domainChangeEventsEnabled) {  
  //     return;  
  //   } 

  //   /* extract version from aggregate to pass down to include in updatedConsumerEvent */
  //   const contact = aggregate.contact;
  //   const version: number = contact.version;

  //   /* create serialized contactCreatedEvent */
  //   const serializedContactUpdatedEvent = this.domainChangeEventFactory.genUpdatedEventFor(updateContactEvent, version);

  //   /* create Outbox Instance of contactCreatedEvent, from createContactEvent */
  //   let contactOutboxInstance: ContactOutbox = await this.outboxService.generateContactUpdatedInstances(
  //         updateContactEvent, 
  //         serializedContactUpdatedEvent
  //       );
  //   /* append instance to the aggregate  */
  //   logTrace && logStop(methodName, 'contactOutboxInstance',contactOutboxInstance);
  //   aggregate.contactOutbox = contactOutboxInstance;
  // }

  // *****************************************************************
  // Helper methods
  // *****************************************************************

  // async getNextOutboxSequence() {
  //    // get query that joins the 3 tables
  //    let sqlStatement = "SELECT NEXTVAL('contact_id_seq')";
  //    const sqlResult = await this.dataSource.query(sqlStatement);
  //    const nextSeqNum = sqlResult[0].nextval;
  //    return nextSeqNum;
  // }

  createAggregateError(email) {
    let createError = new ServerError(500);
    createError.setMessage(ServerErrorReasons.databaseError);
    createError.setReason(`failed to create contact with email:${email} `);
    return createError;
  }
  

}